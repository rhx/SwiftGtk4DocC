{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"TaskRef"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"Asynchronous-operations","level":2,"type":"heading","text":"Asynchronous operations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The most common usage of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" is as a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResult"},{"type":"text","text":", to"},{"type":"text","text":" "},{"type":"text","text":"manage data during an asynchronous operation. You call"},{"type":"text","text":" "},{"type":"codeVoice","code":"g_task_new()"},{"type":"text","text":" in the “start” method, followed by"},{"type":"text","text":" "},{"type":"codeVoice","code":"g_task_set_task_data()"},{"type":"text","text":" and the like if you need to keep some"},{"type":"text","text":" "},{"type":"text","text":"additional data associated with the task, and then pass the"},{"type":"text","text":" "},{"type":"text","text":"task object around through your asynchronous operation."},{"type":"text","text":" "},{"type":"text","text":"Eventually, you will call a method such as"},{"type":"text","text":" "},{"type":"codeVoice","code":"g_task_return_pointer()"},{"type":"text","text":" or "},{"type":"codeVoice","code":"g_task_return_error()"},{"type":"text","text":", which will"},{"type":"text","text":" "},{"type":"text","text":"save the value you give it and then invoke the task’s callback"},{"type":"text","text":" "},{"type":"text","text":"function in the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"#g-main-context-push-thread-default"},{"type":"text","text":" "},{"type":"text","text":"where it was created (waiting until the next iteration of the main"},{"type":"text","text":" "},{"type":"text","text":"loop first, if necessary). The caller will pass the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" back to"},{"type":"text","text":" "},{"type":"text","text":"the operation’s finish function (as a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResult"},{"type":"text","text":"), and you can"},{"type":"text","text":" "},{"type":"text","text":"use "},{"type":"codeVoice","code":"g_task_propagate_pointer()"},{"type":"text","text":" or the like to extract the"},{"type":"text","text":" "},{"type":"text","text":"return value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" requires the thread-default [MainContext](\/\/documentation\/glib\/maincontext from when the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" was constructed to be running at least until the task has completed"},{"type":"text","text":" "},{"type":"text","text":"and its data has been freed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" has been constructed and its callback set, it is an error to"},{"type":"text","text":" "},{"type":"text","text":"not call "},{"type":"codeVoice","code":"g_task_return_*()"},{"type":"text","text":" on it. GLib will warn at runtime if this happens"},{"type":"text","text":" "},{"type":"text","text":"(since 2.76)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is an example for using GTask as a GAsyncResult:"},{"type":"text","text":" "},{"type":"text","text":"(C Language Example):"}]},{"type":"codeListing","syntax":"C","code":["    typedef struct {","      CakeFrostingType frosting;","      char *message;","    } DecorationData;","","    static void","    decoration_data_free (DecorationData *decoration)","    {","      g_free (decoration->message);","      g_slice_free (DecorationData, decoration);","    }","","    static void","    baked_cb (Cake     *cake,","              gpointer  user_data)","    {","      GTask *task = user_data;","      DecorationData *decoration = g_task_get_task_data (task);","      GError *error = NULL;","","      if (cake == NULL)","        {","          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,","                                   \"Go to the supermarket\");","          g_object_unref (task);","          return;","        }","","      if (!cake_decorate (cake, decoration->frosting, decoration->message, &error))","        {","          g_object_unref (cake);","          \/\/ g_task_return_error() takes ownership of error","          g_task_return_error (task, error);","          g_object_unref (task);","          return;","        }","","      g_task_return_pointer (task, cake, g_object_unref);","      g_object_unref (task);","    }","","    void","    baker_bake_cake_async (Baker               *self,","                           guint                radius,","                           CakeFlavor           flavor,","                           CakeFrostingType     frosting,","                           const char          *message,","                           GCancellable        *cancellable,","                           GAsyncReadyCallback  callback,","                           gpointer             user_data)","    {","      GTask *task;","      DecorationData *decoration;","      Cake  *cake;","","      task = g_task_new (self, cancellable, callback, user_data);","      if (radius < 3)","        {","          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_TOO_SMALL,","                                   \"%ucm radius cakes are silly\",","                                   radius);","          g_object_unref (task);","          return;","        }","","      cake = _baker_get_cached_cake (self, radius, flavor, frosting, message);","      if (cake != NULL)","        {","          \/\/ _baker_get_cached_cake() returns a reffed cake","          g_task_return_pointer (task, cake, g_object_unref);","          g_object_unref (task);","          return;","        }","","      decoration = g_slice_new (DecorationData);","      decoration->frosting = frosting;","      decoration->message = g_strdup (message);","      g_task_set_task_data (task, decoration, (GDestroyNotify) decoration_data_free);","","      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);","    }","","    Cake *","    baker_bake_cake_finish (Baker         *self,","                            GAsyncResult  *result,","                            GError       **error)","    {","      g_return_val_if_fail (g_task_is_valid (result, self), NULL);","","      return g_task_propagate_pointer (G_TASK (result), error);","    }"]},{"anchor":"Chained-asynchronous-operations","level":2,"type":"heading","text":"Chained asynchronous operations"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" also tries to simplify asynchronous operations that"},{"type":"text","text":" "},{"type":"text","text":"internally chain together several smaller asynchronous"},{"type":"text","text":" "},{"type":"text","text":"operations. "},{"type":"codeVoice","code":"g_task_get_cancellable()"},{"type":"text","text":", "},{"type":"codeVoice","code":"g_task_get_context()"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":"g_task_get_priority()"},{"type":"text","text":" allow you to get back the task’s"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable"},{"type":"text","text":", [MainContext](\/\/documentation\/glib\/maincontext, and "},{"type":"reference","isActive":true,"identifier":"#io-priority"},{"type":"text","text":" "},{"type":"text","text":"when starting a new subtask, so you don’t have to keep track"},{"type":"text","text":" "},{"type":"text","text":"of them yourself. "},{"type":"codeVoice","code":"g_task_attach_source()"},{"type":"text","text":" simplifies the case"},{"type":"text","text":" "},{"type":"text","text":"of waiting for a source to fire (automatically using the correct"},{"type":"text","text":" "},{"type":"text","text":"[MainContext](\/\/documentation\/glib\/maincontext and priority)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is an example for chained asynchronous operations:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"(C Language Example):"}]},{"type":"codeListing","syntax":"C","code":["    typedef struct {","      Cake *cake;","      CakeFrostingType frosting;","      char *message;","    } BakingData;","","    static void","    decoration_data_free (BakingData *bd)","    {","      if (bd->cake)","        g_object_unref (bd->cake);","      g_free (bd->message);","      g_slice_free (BakingData, bd);","    }","","    static void","    decorated_cb (Cake         *cake,","                  GAsyncResult *result,","                  gpointer      user_data)","    {","      GTask *task = user_data;","      GError *error = NULL;","","      if (!cake_decorate_finish (cake, result, &error))","        {","          g_object_unref (cake);","          g_task_return_error (task, error);","          g_object_unref (task);","          return;","        }","","      \/\/ baking_data_free() will drop its ref on the cake, so we have to","      \/\/ take another here to give to the caller.","      g_task_return_pointer (task, g_object_ref (cake), g_object_unref);","      g_object_unref (task);","    }","","    static gboolean","    decorator_ready (gpointer user_data)","    {","      GTask *task = user_data;","      BakingData *bd = g_task_get_task_data (task);","","      cake_decorate_async (bd->cake, bd->frosting, bd->message,","                           g_task_get_cancellable (task),","                           decorated_cb, task);","","      return G_SOURCE_REMOVE;","    }","","    static void","    baked_cb (Cake     *cake,","              gpointer  user_data)","    {","      GTask *task = user_data;","      BakingData *bd = g_task_get_task_data (task);","      GError *error = NULL;","","      if (cake == NULL)","        {","          g_task_return_new_error (task, BAKER_ERROR, BAKER_ERROR_NO_FLOUR,","                                   \"Go to the supermarket\");","          g_object_unref (task);","          return;","        }","","      bd->cake = cake;","","      \/\/ Bail out now if the user has already cancelled","      if (g_task_return_error_if_cancelled (task))","        {","          g_object_unref (task);","          return;","        }","","      if (cake_decorator_available (cake))","        decorator_ready (task);","      else","        {","          GSource *source;","","          source = cake_decorator_wait_source_new (cake);","          \/\/ Attach @source to @task's GMainContext and have it call","          \/\/ decorator_ready() when it is ready.","          g_task_attach_source (task, source, decorator_ready);","          g_source_unref (source);","        }","    }","","    void","    baker_bake_cake_async (Baker               *self,","                           guint                radius,","                           CakeFlavor           flavor,","                           CakeFrostingType     frosting,","                           const char          *message,","                           gint                 priority,","                           GCancellable        *cancellable,","                           GAsyncReadyCallback  callback,","                           gpointer             user_data)","    {","      GTask *task;","      BakingData *bd;","","      task = g_task_new (self, cancellable, callback, user_data);","      g_task_set_priority (task, priority);","","      bd = g_slice_new0 (BakingData);","      bd->frosting = frosting;","      bd->message = g_strdup (message);","      g_task_set_task_data (task, bd, (GDestroyNotify) baking_data_free);","","      _baker_begin_cake (self, radius, flavor, cancellable, baked_cb, task);","    }","","    Cake *","    baker_bake_cake_finish (Baker         *self,","                            GAsyncResult  *result,","                            GError       **error)","    {","      g_return_val_if_fail (g_task_is_valid (result, self), NULL);","","      return g_task_propagate_pointer (G_TASK (result), error);","    }"]},{"anchor":"Asynchronous-operations-from-synchronous-ones","level":2,"type":"heading","text":"Asynchronous operations from synchronous ones"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use "},{"type":"codeVoice","code":"g_task_run_in_thread()"},{"type":"text","text":" to turn a synchronous"},{"type":"text","text":" "},{"type":"text","text":"operation into an asynchronous one, by running it in a thread."},{"type":"text","text":" "},{"type":"text","text":"When it completes, the result will be dispatched to the"},{"type":"text","text":" "},{"overridingTitleInlineContent":[{"type":"text","text":"thread-default main context"}],"isActive":true,"type":"reference","identifier":"#g-main-context-push-thread-default","overridingTitle":"thread-default main context"},{"type":"text","text":" "},{"type":"text","text":"where the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" was created."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Running a task in a thread:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"(C Language Example):"}]},{"type":"codeListing","syntax":"C","code":["    typedef struct {","      guint radius;","      CakeFlavor flavor;","      CakeFrostingType frosting;","      char *message;","    } CakeData;","","    static void","    cake_data_free (CakeData *cake_data)","    {","      g_free (cake_data->message);","      g_slice_free (CakeData, cake_data);","    }","","    static void","    bake_cake_thread (GTask         *task,","                      gpointer       source_object,","                      gpointer       task_data,","                      GCancellable  *cancellable)","    {","      Baker *self = source_object;","      CakeData *cake_data = task_data;","      Cake *cake;","      GError *error = NULL;","","      cake = bake_cake (baker, cake_data->radius, cake_data->flavor,","                        cake_data->frosting, cake_data->message,","                        cancellable, &error);","      if (cake)","        g_task_return_pointer (task, cake, g_object_unref);","      else","        g_task_return_error (task, error);","    }","","    void","    baker_bake_cake_async (Baker               *self,","                           guint                radius,","                           CakeFlavor           flavor,","                           CakeFrostingType     frosting,","                           const char          *message,","                           GCancellable        *cancellable,","                           GAsyncReadyCallback  callback,","                           gpointer             user_data)","    {","      CakeData *cake_data;","      GTask *task;","","      cake_data = g_slice_new (CakeData);","      cake_data->radius = radius;","      cake_data->flavor = flavor;","      cake_data->frosting = frosting;","      cake_data->message = g_strdup (message);","      task = g_task_new (self, cancellable, callback, user_data);","      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);","      g_task_run_in_thread (task, bake_cake_thread);","      g_object_unref (task);","    }","","    Cake *","    baker_bake_cake_finish (Baker         *self,","                            GAsyncResult  *result,","                            GError       **error)","    {","      g_return_val_if_fail (g_task_is_valid (result, self), NULL);","","      return g_task_propagate_pointer (G_TASK (result), error);","    }"]},{"anchor":"Adding-cancellability-to-uncancellable-tasks","level":2,"type":"heading","text":"Adding cancellability to uncancellable tasks"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, "},{"type":"codeVoice","code":"g_task_run_in_thread()"},{"type":"text","text":" and "},{"type":"codeVoice","code":"g_task_run_in_thread_sync()"},{"type":"text","text":" "},{"type":"text","text":"can be used to turn an uncancellable operation into a"},{"type":"text","text":" "},{"type":"text","text":"cancellable one. If you call "},{"type":"codeVoice","code":"g_task_set_return_on_cancel()"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"passing "},{"type":"codeVoice","code":"true"},{"type":"text","text":", then if the task’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable"},{"type":"text","text":" is cancelled,"},{"type":"text","text":" "},{"type":"text","text":"it will return control back to the caller immediately, while"},{"type":"text","text":" "},{"type":"text","text":"allowing the task thread to continue running in the background"},{"type":"text","text":" "},{"type":"text","text":"(and simply discarding its result when it finally does finish)."},{"type":"text","text":" "},{"type":"text","text":"Provided that the task thread is careful about how it uses"},{"type":"text","text":" "},{"type":"text","text":"locks and other externally-visible resources, this allows you"},{"type":"text","text":" "},{"type":"text","text":"to make “GLib-friendly” asynchronous and cancellable"},{"type":"text","text":" "},{"type":"text","text":"synchronous variants of blocking APIs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Cancelling a task:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"(C Language Example):"}]},{"type":"codeListing","syntax":"C","code":["    static void","    bake_cake_thread (GTask         *task,","                      gpointer       source_object,","                      gpointer       task_data,","                      GCancellable  *cancellable)","    {","      Baker *self = source_object;","      CakeData *cake_data = task_data;","      Cake *cake;","      GError *error = NULL;","","      cake = bake_cake (baker, cake_data->radius, cake_data->flavor,","                        cake_data->frosting, cake_data->message,","                        &error);","      if (error)","        {","          g_task_return_error (task, error);","          return;","        }","","      \/\/ If the task has already been cancelled, then we don't want to add","      \/\/ the cake to the cake cache. Likewise, we don't  want to have the","      \/\/ task get cancelled in the middle of updating the cache.","      \/\/ g_task_set_return_on_cancel() will return %TRUE here if it managed","      \/\/ to disable return-on-cancel, or %FALSE if the task was cancelled","      \/\/ before it could.","      if (g_task_set_return_on_cancel (task, FALSE))","        {","          \/\/ If the caller cancels at this point, their","          \/\/ GAsyncReadyCallback won't be invoked until we return,","          \/\/ so we don't have to worry that this code will run at","          \/\/ the same time as that code does. But if there were","          \/\/ other functions that might look at the cake cache,","          \/\/ then we'd probably need a GMutex here as well.","          baker_add_cake_to_cache (baker, cake);","          g_task_return_pointer (task, cake, g_object_unref);","        }","    }","","    void","    baker_bake_cake_async (Baker               *self,","                           guint                radius,","                           CakeFlavor           flavor,","                           CakeFrostingType     frosting,","                           const char          *message,","                           GCancellable        *cancellable,","                           GAsyncReadyCallback  callback,","                           gpointer             user_data)","    {","      CakeData *cake_data;","      GTask *task;","","      cake_data = g_slice_new (CakeData);","","      ...","","      task = g_task_new (self, cancellable, callback, user_data);","      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);","      g_task_set_return_on_cancel (task, TRUE);","      g_task_run_in_thread (task, bake_cake_thread);","    }","","    Cake *","    baker_bake_cake_sync (Baker               *self,","                          guint                radius,","                          CakeFlavor           flavor,","                          CakeFrostingType     frosting,","                          const char          *message,","                          GCancellable        *cancellable,","                          GError             **error)","    {","      CakeData *cake_data;","      GTask *task;","      Cake *cake;","","      cake_data = g_slice_new (CakeData);","","      ...","","      task = g_task_new (self, cancellable, NULL, NULL);","      g_task_set_task_data (task, cake_data, (GDestroyNotify) cake_data_free);","      g_task_set_return_on_cancel (task, TRUE);","      g_task_run_in_thread_sync (task, bake_cake_thread);","","      cake = g_task_propagate_pointer (task, error);","      g_object_unref (task);","      return cake;","    }"]},{"anchor":"Porting-from-GSimpleAsyncResult","level":2,"type":"heading","text":"Porting from GSimpleAsyncResult"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":"’s API attempts to be simpler than "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":"’s"},{"type":"text","text":" "},{"type":"text","text":"in several ways:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You can save task-specific data with "},{"type":"codeVoice","code":"g_task_set_task_data()"},{"type":"text","text":", and"},{"type":"text","text":" "},{"type":"text","text":"retrieve it later with "},{"type":"codeVoice","code":"g_task_get_task_data()"},{"type":"text","text":". This replaces the"},{"type":"text","text":" "},{"type":"text","text":"abuse of "},{"type":"codeVoice","code":"g_simple_async_result_set_op_res_gpointer()"},{"type":"text","text":" for the same"},{"type":"text","text":" "},{"type":"text","text":"purpose with "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":"."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to the task data, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" also keeps track of the"},{"type":"text","text":" "},{"overridingTitleInlineContent":[{"type":"text","text":"priority"}],"isActive":true,"type":"reference","identifier":"#io-priority","overridingTitle":"priority"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable"},{"type":"text","text":", and"},{"type":"text","text":" "},{"type":"text","text":"[MainContext](\/\/documentation\/glib\/maincontext associated with the task, so tasks that consist of"},{"type":"text","text":" "},{"type":"text","text":"a chain of simpler asynchronous operations will have easy access"},{"type":"text","text":" "},{"type":"text","text":"to those values when starting each sub-task."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"g_task_return_error_if_cancelled()"},{"type":"text","text":" provides simplified"},{"type":"text","text":" "},{"type":"text","text":"handling for cancellation. In addition, cancellation"},{"type":"text","text":" "},{"type":"text","text":"overrides any other "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" return value by default, like"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":" does when"},{"type":"text","text":" "},{"type":"codeVoice","code":"g_simple_async_result_set_check_cancellable()"},{"type":"text","text":" is called."},{"type":"text","text":" "},{"type":"text","text":"(You can use "},{"type":"codeVoice","code":"g_task_set_check_cancellable()"},{"type":"text","text":" to turn off that"},{"type":"text","text":" "},{"type":"text","text":"behavior.) On the other hand, "},{"type":"codeVoice","code":"g_task_run_in_thread()"},{"type":"text","text":" "},{"type":"text","text":"guarantees that it will always run your"},{"type":"text","text":" "},{"type":"codeVoice","code":"task_func"},{"type":"text","text":", even if the task’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable"},{"type":"text","text":" "},{"type":"text","text":"is already cancelled before the task gets a chance to run;"},{"type":"text","text":" "},{"type":"text","text":"you can start your "},{"type":"codeVoice","code":"task_func"},{"type":"text","text":" with a"},{"type":"text","text":" "},{"type":"codeVoice","code":"g_task_return_error_if_cancelled()"},{"type":"text","text":" check if you need the"},{"type":"text","text":" "},{"type":"text","text":"old behavior."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The “return” methods (eg, "},{"type":"codeVoice","code":"g_task_return_pointer()"},{"type":"text","text":")"},{"type":"text","text":" "},{"type":"text","text":"automatically cause the task to be “completed” as well, and"},{"type":"text","text":" "},{"type":"text","text":"there is no need to worry about the “complete” vs “complete"},{"type":"text","text":" "},{"type":"text","text":"in idle” distinction. ("},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" automatically figures out"},{"type":"text","text":" "},{"type":"text","text":"whether the task’s callback can be invoked directly, or"},{"type":"text","text":" "},{"type":"text","text":"if it needs to be sent to another [MainContext](\/\/documentation\/glib\/maincontext, or delayed"},{"type":"text","text":" "},{"type":"text","text":"until the next iteration of the current "},{"type":"reference","isActive":true,"identifier":"\/\/documentation\/glib\/maincontext."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The “finish” functions for "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" based operations are generally"},{"type":"text","text":" "},{"type":"text","text":"much simpler than "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":" ones, normally consisting"},{"type":"text","text":" "},{"type":"text","text":"of only a single call to "},{"type":"codeVoice","code":"g_task_propagate_pointer()"},{"type":"text","text":" or the like."},{"type":"text","text":" "},{"type":"text","text":"Since "},{"type":"codeVoice","code":"g_task_propagate_pointer()"},{"type":"text","text":" “steals” the return value from"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":", it is not necessary to juggle pointers around to"},{"type":"text","text":" "},{"type":"text","text":"prevent it from being freed twice."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"With "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":", it was common to call"},{"type":"text","text":" "},{"type":"codeVoice","code":"g_simple_async_result_propagate_error()"},{"type":"text","text":" from the"},{"type":"text","text":" "},{"type":"codeVoice","code":"_finish()"},{"type":"text","text":" wrapper function, and have"},{"type":"text","text":" "},{"type":"text","text":"virtual method implementations only deal with successful"},{"type":"text","text":" "},{"type":"text","text":"returns. This behavior is deprecated, because it makes it"},{"type":"text","text":" "},{"type":"text","text":"difficult for a subclass to chain to a parent class’s async"},{"type":"text","text":" "},{"type":"text","text":"methods. Instead, the wrapper function should just be a"},{"type":"text","text":" "},{"type":"text","text":"simple wrapper, and the virtual method should call an"},{"type":"text","text":" "},{"type":"text","text":"appropriate "},{"type":"codeVoice","code":"g_task_propagate_"},{"type":"text","text":" function."},{"type":"text","text":" "},{"type":"text","text":"Note that wrapper methods can now use"},{"type":"text","text":" "},{"type":"codeVoice","code":"g_async_result_legacy_propagate_error()"},{"type":"text","text":" to do old-style"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":" error-returning behavior, and"},{"type":"text","text":" "},{"type":"codeVoice","code":"g_async_result_is_tagged()"},{"type":"text","text":" to check if a result is tagged as"},{"type":"text","text":" "},{"type":"text","text":"having come from the "},{"type":"codeVoice","code":"_async()"},{"type":"text","text":" wrapper"},{"type":"text","text":" "},{"type":"text","text":"function (for “short-circuit” results, such as when passing"},{"type":"text","text":" "},{"type":"text","text":"0 to "},{"type":"codeVoice","code":"g_input_stream_read_async()"},{"type":"text","text":")."}]}]}]},{"anchor":"Thread-safety-considerations","level":2,"type":"heading","text":"Thread-safety considerations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Due to some infelicities in the API design, there is a"},{"type":"text","text":" "},{"type":"text","text":"thread-safety concern that users of GTask have to be aware of:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the "},{"type":"codeVoice","code":"main"},{"type":"text","text":" thread drops its last reference to the source object"},{"type":"text","text":" "},{"type":"text","text":"or the task data before the task is finalized, then the finalizers"},{"type":"text","text":" "},{"type":"text","text":"of these objects may be called on the worker thread."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a problem if the finalizers use non-threadsafe API, and"},{"type":"text","text":" "},{"type":"text","text":"can lead to hard-to-debug crashes. Possible workarounds include:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Clear task data in a signal handler for "},{"type":"codeVoice","code":"notify"},{"type":"text","text":"completed``"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Keep iterating a main context in the main thread and defer"},{"type":"text","text":" "},{"type":"text","text":"dropping the reference to the source object to that main"},{"type":"text","text":" "},{"type":"text","text":"context when the task is finalized"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef"},{"type":"text","text":" type acts as a lightweight Swift reference to an underlying "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."},{"type":"text","text":" "},{"type":"text","text":"It exposes methods that can operate on this data type through "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":" conformance."},{"type":"text","text":" "},{"type":"text","text":"Use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef"},{"type":"text","text":" only as an "},{"type":"codeVoice","code":"unowned"},{"type":"text","text":" reference to an existing "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" (instead of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef"},{"type":"text","text":") if you want to use Automatic Reference Counting for memory management of the underlying "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."}]}],"type":"aside","name":"Note"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/gio\/taskref"],"traits":[{"interfaceLanguage":"swift"}]}],"relationshipsSections":[{"identifiers":["doc:\/\/GIO\/documentation\/GIO\/AsyncResultProtocol","doc:\/\/GIO\/4GLib14PointerWrapperP","doc:\/\/GIO\/10GLibObject14GWeakCapturingP","doc:\/\/GIO\/10GLibObject0B8ProtocolP","doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"],"kind":"relationships","title":"Conforms To","type":"conformsTo"}],"identifier":{"url":"doc:\/\/GIO\/documentation\/GIO\/TaskRef","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" represents and manages a cancellable “task”."}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"TaskRef"}],"title":"TaskRef","roleHeading":"Structure","role":"symbol","symbolKind":"struct","externalID":"s:3GIO7TaskRefV","modules":[{"name":"GIO"}],"navigatorTitle":[{"kind":"identifier","text":"TaskRef"}]},"hierarchy":{"paths":[["doc:\/\/GIO\/documentation\/GIO"]]},"topicSections":[{"title":"Initializers","identifiers":["doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-32s71","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-4ds1b","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-69ozl","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-7lz59","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-o7qi","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(cPointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(constPointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(gconstpointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(gpointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(mutating:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(opaquePointer:)","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(sourceObject:cancellable:callback:callbackData:)"]},{"title":"Instance Properties","identifiers":["doc:\/\/GIO\/documentation\/GIO\/TaskRef\/ptr"]},{"title":"Type Methods","identifiers":["doc:\/\/GIO\/documentation\/GIO\/TaskRef\/unowned(_:)"]},{"title":"Default Implementations","identifiers":["doc:\/\/GIO\/documentation\/GIO\/TaskRef\/AsyncResultProtocol-Implementations","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/GWeakCapturing-Implementations","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/ObjectProtocol-Implementations","doc:\/\/GIO\/documentation\/GIO\/TaskRef\/TaskProtocol-Implementations"],"generated":true}],"references":{"//documentation/glib/maincontext.":{"title":"MainContext","titleInlineContent":[{"type":"text","text":"MainContext"}],"type":"link","identifier":"\/\/documentation\/glib\/maincontext.","url":"\/\/documentation\/glib\/maincontext."},"doc://GIO/documentation/GIO/TaskRef/init(mutating:)":{"role":"symbol","title":"init(mutating:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"mutating"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeRawPointer","preciseIdentifier":"s:SV"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Unsafe untyped initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(mutating:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(mutating:)"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-4ds1b":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Designated initialiser from the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-4ds1b","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-4ds1b"},"#io-priority":{"title":"I\/O priority","titleInlineContent":[{"type":"text","text":"I\/O priority"}],"type":"link","identifier":"#io-priority","url":"#io-priority"},"doc://GIO/documentation/GIO/TaskRef/GWeakCapturing-Implementations":{"role":"collectionGroup","title":"GWeakCapturing Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/GWeakCapturing-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/taskref\/gweakcapturing-implementations"},"doc://GIO/documentation/GIO/TaskRef/init(cPointer:)":{"role":"symbol","title":"init(cPointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"cPointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Unsafe typed initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(cPointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(cpointer:)"},"doc://GIO/documentation/GIO/TaskRef":{"role":"symbol","title":"TaskRef","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"TaskRef"}],"abstract":[{"type":"text","text":"A "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" represents and manages a cancellable “task”."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TaskRef"}],"url":"\/documentation\/gio\/taskref"},"doc://GIO/documentation/GIO/TaskRef/AsyncResultProtocol-Implementations":{"role":"collectionGroup","title":"AsyncResultProtocol Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/AsyncResultProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/taskref\/asyncresultprotocol-implementations"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-69ozl":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Designated initialiser from a constant pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-69ozl","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-69ozl"},"doc://GIO/documentation/GIO/TaskRef/TaskProtocol-Implementations":{"role":"collectionGroup","title":"TaskProtocol Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/TaskProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/taskref\/taskprotocol-implementations"},"doc://GIO/documentation/GIO/TaskRef/ObjectProtocol-Implementations":{"role":"collectionGroup","title":"ObjectProtocol Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/ObjectProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/taskref\/objectprotocol-implementations"},"#g-main-context-push-thread-default":{"title":"thread-default main context","titleInlineContent":[{"type":"text","text":"thread-default main context"}],"type":"link","identifier":"#g-main-context-push-thread-default","url":"#g-main-context-push-thread-default"},"doc://GIO/documentation/GIO":{"role":"collection","title":"GIO","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO","kind":"symbol","type":"topic","url":"\/documentation\/gio"},"doc://GIO/documentation/GIO/TaskRef/init(opaquePointer:)":{"role":"symbol","title":"init(opaquePointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"opaquePointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"OpaquePointer","preciseIdentifier":"s:s13OpaquePointerV"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Unsafe untyped initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(opaquePointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(opaquepointer:)"},"doc://GIO/documentation/GIO/TaskRef/unowned(_:)":{"role":"symbol","title":"unowned(_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"unowned"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"TaskRef","preciseIdentifier":"s:3GIO7TaskRefV"}],"abstract":[{"type":"text","text":"This factory is syntactic sugar for setting weak pointers wrapped in "},{"type":"codeVoice","code":"GWeak<T>"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/unowned(_:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/unowned(_:)"},"doc://GIO/documentation/GIO/TaskProtocol/task_ptr-2ullq":{"defaultImplementations":1,"role":"symbol","title":"task_ptr","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"task_ptr"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">!"}],"abstract":[{"type":"text","text":"Typed pointer to the underlying "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol\/task_ptr-2ullq","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/gio\/taskprotocol\/task_ptr-2ullq"},"doc://GIO/documentation/GIO/AsyncResultProtocol":{"role":"symbol","title":"AsyncResultProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncResultProtocol"}],"abstract":[{"type":"text","text":"Provides a base class for implementing asynchronous function results."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResultProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AsyncResultProtocol"}],"url":"\/documentation\/gio\/asyncresultprotocol"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-7lz59":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional, non-mutable pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-7lz59","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-7lz59"},"doc://GIO/documentation/GIO/Cancellable":{"role":"symbol","title":"Cancellable","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Cancellable"}],"abstract":[{"type":"text","text":"GCancellable is a thread-safe operation cancellation stack used"},{"type":"text","text":" "},{"type":"text","text":"throughout GIO to allow for cancellation of synchronous and"},{"type":"text","text":" "},{"type":"text","text":"asynchronous operations."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/Cancellable","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Cancellable"}],"url":"\/documentation\/gio\/cancellable"},"doc://GIO/documentation/GIO/SimpleAsyncResult":{"role":"symbol","title":"SimpleAsyncResult","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"SimpleAsyncResult"}],"abstract":[{"type":"text","text":"As of GLib 2.46, "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult"},{"type":"text","text":" is deprecated in favor of"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":", which provides a simpler API."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/SimpleAsyncResult","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SimpleAsyncResult"}],"url":"\/documentation\/gio\/simpleasyncresult"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-32s71":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GTask"},{"kind":"text","text":">?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-32s71","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-32s71"},"doc://GIO/documentation/GIO/TaskRef/init(constPointer:)":{"role":"symbol","title":"init(constPointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"constPointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Unsafe typed initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(constPointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(constpointer:)"},"doc://GIO/documentation/GIO/TaskProtocol":{"role":"symbol","title":"TaskProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"TaskProtocol"}],"abstract":[{"type":"text","text":"A "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" represents and manages a cancellable “task”."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TaskProtocol"}],"url":"\/documentation\/gio\/taskprotocol"},"doc://GIO/documentation/GIO/TaskRef/ptr":{"role":"symbol","title":"ptr","fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"ptr"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!"}],"abstract":[{"type":"text","text":"Untyped pointer to the underlying "},{"type":"codeVoice","code":"GTask"},{"type":"text","text":" instance."},{"type":"text","text":" "},{"type":"text","text":"For type-safe access, use the generated, typed pointer "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol\/task_ptr-2ullq"},{"type":"text","text":" property instead."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/ptr","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/ptr"},"doc://GIO/documentation/GIO/TaskRef/init(_:)-o7qi":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Reference intialiser for a related type that implements "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskProtocol"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(_:)-o7qi","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(_:)-o7qi"},"doc://GIO/documentation/GIO/TaskRef/init(sourceObject:cancellable:callback:callbackData:)":{"role":"symbol","title":"init(sourceObject:cancellable:callback:callbackData:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"CancellableT"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"GObjectObjectT"},{"kind":"text","text":">("},{"kind":"externalParam","text":"sourceObject"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"GObjectObjectT"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"cancellable"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"CancellableT"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"callback"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"GAsyncReadyCallback","preciseIdentifier":"c:@T@GAsyncReadyCallback"},{"kind":"text","text":"?, "},{"kind":"externalParam","text":"callbackData"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"gpointer","preciseIdentifier":"c:gtypes.h@T@gpointer"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Creates a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" acting on "},{"type":"codeVoice","code":"sourceObject"},{"type":"text","text":", which will eventually be"},{"type":"text","text":" "},{"type":"text","text":"used to invoke "},{"type":"codeVoice","code":"callback"},{"type":"text","text":" in the current"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"#g-main-context-push-thread-default"},{"type":"text","text":"."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(sourceObject:cancellable:callback:callbackData:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(sourceobject:cancellable:callback:callbackdata:)"},"doc://GIO/documentation/GIO/TaskRef/init(gpointer:)":{"role":"symbol","title":"init(gpointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"externalParam","text":"gpointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"gpointer","preciseIdentifier":"c:gtypes.h@T@gpointer"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional "},{"type":"codeVoice","code":"gpointer"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(gpointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(gpointer:)"},"doc://GIO/10GLibObject0B8ProtocolP":{"type":"unresolvable","title":"GLibObject.ObjectProtocol","identifier":"doc:\/\/GIO\/10GLibObject0B8ProtocolP"},"doc://GIO/documentation/GIO/TaskRef/init(gconstpointer:)":{"role":"symbol","title":"init(gconstpointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"externalParam","text":"gconstpointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"gconstpointer","preciseIdentifier":"c:gtypes.h@T@gconstpointer"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional, non-mutable "},{"type":"codeVoice","code":"gconstpointer"}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/TaskRef\/init(gconstpointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/taskref\/init(gconstpointer:)"},"doc://GIO/documentation/GIO/Task":{"role":"symbol","title":"Task","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Task"}],"abstract":[{"type":"text","text":"A "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task"},{"type":"text","text":" represents and manages a cancellable “task”."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/Task","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Task"}],"url":"\/documentation\/gio\/task"},"doc://GIO/10GLibObject14GWeakCapturingP":{"type":"unresolvable","title":"GLibObject.GWeakCapturing","identifier":"doc:\/\/GIO\/10GLibObject14GWeakCapturingP"},"doc://GIO/4GLib14PointerWrapperP":{"type":"unresolvable","title":"GLib.PointerWrapper","identifier":"doc:\/\/GIO\/4GLib14PointerWrapperP"},"doc://GIO/documentation/GIO/AsyncResult":{"role":"symbol","title":"AsyncResult","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsyncResult"}],"abstract":[{"type":"text","text":"Provides a base class for implementing asynchronous function results."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/AsyncResult","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AsyncResult"}],"url":"\/documentation\/gio\/asyncresult"}}}