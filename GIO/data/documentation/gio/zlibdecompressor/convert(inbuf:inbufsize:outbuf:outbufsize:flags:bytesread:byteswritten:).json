{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"convert"},{"kind":"text","text":"("},{"kind":"externalParam","text":"inbuf"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!, "},{"kind":"externalParam","text":"inbufSize"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":", "},{"kind":"externalParam","text":"outbuf"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!, "},{"kind":"externalParam","text":"outbufSize"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":", "},{"kind":"externalParam","text":"flags"},{"kind":"text","text":": "},{"kind":"typeIdentifier","identifier":"doc:\/\/GIO\/documentation\/GIO\/ConverterFlags","preciseIdentifier":"s:3GIO14ConverterFlagsV","text":"ConverterFlags"},{"kind":"text","text":", "},{"kind":"externalParam","text":"bytesRead"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"gsize","preciseIdentifier":"c:@T@gsize"},{"kind":"text","text":">!, "},{"kind":"externalParam","text":"bytesWritten"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"gsize","preciseIdentifier":"c:@T@gsize"},{"kind":"text","text":">!) "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"GConverterResult","preciseIdentifier":"c:@EA@GConverterResult"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"discussion","level":2,"type":"heading","text":"Discussion"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that a single call may not consume all input (or any input at all)."},{"type":"text","text":" "},{"type":"text","text":"Also a call may produce output even if given no input, due to state stored"},{"type":"text","text":" "},{"type":"text","text":"in the converter producing output."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If any data was either produced or consumed, and then an error happens, then"},{"type":"text","text":" "},{"type":"text","text":"only the successful conversion is reported and the error is returned on the"},{"type":"text","text":" "},{"type":"text","text":"next call."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A full conversion loop involves calling this method repeatedly, each time"},{"type":"text","text":" "},{"type":"text","text":"giving it new input and space output space. When there is no more input"},{"type":"text","text":" "},{"type":"text","text":"data after the data in "},{"type":"codeVoice","code":"inbuf"},{"type":"text","text":", the flag "},{"type":"codeVoice","code":"inputAtEnd"},{"type":"text","text":" must be set."},{"type":"text","text":" "},{"type":"text","text":"The loop will be (unless some error happens) returning "},{"type":"codeVoice","code":"converted"},{"type":"text","text":" "},{"type":"text","text":"each time until all data is consumed and all output is produced, then"},{"type":"text","text":" "},{"type":"codeVoice","code":"finished"},{"type":"text","text":" is returned instead. Note, that "},{"type":"codeVoice","code":"finished"},{"type":"text","text":" "},{"type":"text","text":"may be returned even if "},{"type":"codeVoice","code":"inputAtEnd"},{"type":"text","text":" is not set, for instance"},{"type":"text","text":" "},{"type":"text","text":"in a decompression converter where the end of data is detectable from the"},{"type":"text","text":" "},{"type":"text","text":"data (and there might even be other data after the end of the compressed data)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When some data has successfully been converted "},{"type":"codeVoice","code":"bytesRead"},{"type":"text","text":" and is set to"},{"type":"text","text":" "},{"type":"text","text":"the number of bytes read from "},{"type":"codeVoice","code":"inbuf"},{"type":"text","text":", and "},{"type":"codeVoice","code":"bytesWritten"},{"type":"text","text":" is set to indicate"},{"type":"text","text":" "},{"type":"text","text":"how many bytes was written to "},{"type":"codeVoice","code":"outbuf"},{"type":"text","text":". If there are more data to output"},{"type":"text","text":" "},{"type":"text","text":"or consume (i.e. unless the "},{"type":"codeVoice","code":"inputAtEnd"},{"type":"text","text":" is specified) then"},{"type":"text","text":" "},{"type":"codeVoice","code":"converted"},{"type":"text","text":" is returned, and if no more data is to be output"},{"type":"text","text":" "},{"type":"text","text":"then "},{"type":"codeVoice","code":"finished"},{"type":"text","text":" is returned."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"On error "},{"type":"codeVoice","code":"error"},{"type":"text","text":" is returned and "},{"type":"codeVoice","code":"error"},{"type":"text","text":" is set accordingly."},{"type":"text","text":" "},{"type":"text","text":"Some errors need special handling:"}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"noSpace"},{"type":"text","text":" is returned if there is not enough space"},{"type":"text","text":" "},{"type":"text","text":"to write the resulting converted data, the application should"},{"type":"text","text":" "},{"type":"text","text":"call the function again with a larger "},{"type":"codeVoice","code":"outbuf"},{"type":"text","text":" to continue."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"partialInput"},{"type":"text","text":" is returned if there is not enough"},{"type":"text","text":" "},{"type":"text","text":"input to fully determine what the conversion should produce,"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"inputAtEnd"},{"type":"text","text":" flag is not set. This happens for"},{"type":"text","text":" "},{"type":"text","text":"example with an incomplete multibyte sequence when converting text,"},{"type":"text","text":" "},{"type":"text","text":"or when a regexp matches up to the end of the input (and may match"},{"type":"text","text":" "},{"type":"text","text":"further input). It may also happen when "},{"type":"codeVoice","code":"inbufSize"},{"type":"text","text":" is zero and"},{"type":"text","text":" "},{"type":"text","text":"there is no more data to produce."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When this happens the application should read more input and then"},{"type":"text","text":" "},{"type":"text","text":"call the function again. If further input shows that there is no"},{"type":"text","text":" "},{"type":"text","text":"more data call the function again with the same data but with"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"inputAtEnd"},{"type":"text","text":" flag set. This may cause the conversion"},{"type":"text","text":" "},{"type":"text","text":"to finish as e.g. in the regexp match case (or, to fail again with"},{"type":"text","text":" "},{"type":"codeVoice","code":"partialInput"},{"type":"text","text":" in e.g. a charset conversion where the"},{"type":"text","text":" "},{"type":"text","text":"input is actually partial)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"After "},{"type":"codeVoice","code":"g_converter_convert()"},{"type":"text","text":" has returned "},{"type":"codeVoice","code":"finished"},{"type":"text","text":" the"},{"type":"text","text":" "},{"type":"text","text":"converter object is in an invalid state where its not allowed"},{"type":"text","text":" "},{"type":"text","text":"to call "},{"type":"codeVoice","code":"g_converter_convert()"},{"type":"text","text":" anymore. At this time you can only"},{"type":"text","text":" "},{"type":"text","text":"free the object or call "},{"type":"codeVoice","code":"g_converter_reset()"},{"type":"text","text":" to reset it to the"},{"type":"text","text":" "},{"type":"text","text":"initial state."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the flag "},{"type":"codeVoice","code":"flush"},{"type":"text","text":" is set then conversion is modified"},{"type":"text","text":" "},{"type":"text","text":"to try to write out all internal state to the output. The application"},{"type":"text","text":" "},{"type":"text","text":"has to call the function multiple times with the flag set, and when"},{"type":"text","text":" "},{"type":"text","text":"the available input has been consumed and all internal state has"},{"type":"text","text":" "},{"type":"text","text":"been produced then "},{"type":"codeVoice","code":"flushed"},{"type":"text","text":" (or "},{"type":"codeVoice","code":"finished"},{"type":"text","text":" if"},{"type":"text","text":" "},{"type":"text","text":"really at the end) is returned instead of "},{"type":"codeVoice","code":"converted"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This is somewhat similar to what happens at the end of the input stream,"},{"type":"text","text":" "},{"type":"text","text":"but done in the middle of the data."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This has different meanings for different conversions. For instance"},{"type":"text","text":" "},{"type":"text","text":"in a compression converter it would mean that we flush all the"},{"type":"text","text":" "},{"type":"text","text":"compression state into output such that if you uncompress the"},{"type":"text","text":" "},{"type":"text","text":"compressed data you get back all the input data. Doing this may"},{"type":"text","text":" "},{"type":"text","text":"make the final file larger due to padding though. Another example"},{"type":"text","text":" "},{"type":"text","text":"is a regexp conversion, where if you at the end of the flushed data"},{"type":"text","text":" "},{"type":"text","text":"have a match, but there is also a potential longer match. In the"},{"type":"text","text":" "},{"type":"text","text":"non-flushed case we would ask for more input, but when flushing we"},{"type":"text","text":" "},{"type":"text","text":"treat this as the end of input and do the match."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Flushing is not always possible (like if a charset converter flushes"},{"type":"text","text":" "},{"type":"text","text":"at a partial multibyte sequence). Converters are supposed to try"},{"type":"text","text":" "},{"type":"text","text":"to produce as much output as possible and then return an error"},{"type":"text","text":" "},{"type":"text","text":"(typically "},{"type":"codeVoice","code":"partialInput"},{"type":"text","text":")."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/gio\/zlibdecompressor\/convert(inbuf:inbufsize:outbuf:outbufsize:flags:bytesread:byteswritten:)"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/GIO\/documentation\/GIO\/ZlibDecompressor\/convert(inbuf:inbufSize:outbuf:outbufSize:flags:bytesRead:bytesWritten:)","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"This is the main operation used when converting data. It is to be called"},{"type":"text","text":" "},{"type":"text","text":"multiple times in a loop, and each time it will do some work, i.e."},{"type":"text","text":" "},{"type":"text","text":"producing some output (in "},{"type":"codeVoice","code":"outbuf"},{"type":"text","text":") or consuming some input (from "},{"type":"codeVoice","code":"inbuf"},{"type":"text","text":") or"},{"type":"text","text":" "},{"type":"text","text":"both. If its not possible to do any work an error is returned."}],"kind":"symbol","metadata":{"role":"symbol","title":"convert(inbuf:inbufSize:outbuf:outbufSize:flags:bytesRead:bytesWritten:)","roleHeading":"Instance Method","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"convert"},{"kind":"text","text":"("},{"kind":"externalParam","text":"inbuf"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!, "},{"kind":"externalParam","text":"inbufSize"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":", "},{"kind":"externalParam","text":"outbuf"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!, "},{"kind":"externalParam","text":"outbufSize"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":", "},{"kind":"externalParam","text":"flags"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ConverterFlags","preciseIdentifier":"s:3GIO14ConverterFlagsV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"bytesRead"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"gsize","preciseIdentifier":"c:@T@gsize"},{"kind":"text","text":">!, "},{"kind":"externalParam","text":"bytesWritten"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"gsize","preciseIdentifier":"c:@T@gsize"},{"kind":"text","text":">!) "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"GConverterResult","preciseIdentifier":"c:@EA@GConverterResult"}],"symbolKind":"method","externalID":"s:3GIO17ConverterProtocolPAAE7convert5inbuf0E4Size6outbuf0gF05flags9bytesRead0I7WrittenSo16GConverterResultaSvSg_SiANSiAA0B5FlagsVSpySuGSgARtKF::SYNTHESIZED::s:3GIO16ZlibDecompressorC","extendedModule":"GIO","modules":[{"name":"GIO"}]},"hierarchy":{"paths":[["doc:\/\/GIO\/documentation\/GIO","doc:\/\/GIO\/documentation\/GIO\/ZlibDecompressor","doc:\/\/GIO\/documentation\/GIO\/ZlibDecompressor\/ConverterProtocol-Implementations"]]},"references":{"doc://GIO/documentation/GIO/ConverterFlags":{"role":"symbol","title":"ConverterFlags","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ConverterFlags"}],"abstract":[{"type":"text","text":"Flags used when calling a "},{"type":"codeVoice","code":"g_converter_convert()"},{"type":"text","text":"."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/ConverterFlags","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ConverterFlags"}],"url":"\/documentation\/gio\/converterflags"},"doc://GIO/documentation/GIO/ZlibDecompressor":{"role":"symbol","title":"ZlibDecompressor","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ZlibDecompressor"}],"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/ZlibDecompressor"},{"type":"text","text":" is an implementation of "},{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Converter"},{"type":"text","text":" that"},{"type":"text","text":" "},{"type":"text","text":"decompresses data compressed with zlib."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/ZlibDecompressor","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ZlibDecompressor"}],"url":"\/documentation\/gio\/zlibdecompressor"},"doc://GIO/documentation/GIO/ZlibDecompressor/convert(inbuf:inbufSize:outbuf:outbufSize:flags:bytesRead:bytesWritten:)":{"role":"symbol","title":"convert(inbuf:inbufSize:outbuf:outbufSize:flags:bytesRead:bytesWritten:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"convert"},{"kind":"text","text":"("},{"kind":"externalParam","text":"inbuf"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!, "},{"kind":"externalParam","text":"inbufSize"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":", "},{"kind":"externalParam","text":"outbuf"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!, "},{"kind":"externalParam","text":"outbufSize"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"},{"kind":"text","text":", "},{"kind":"externalParam","text":"flags"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ConverterFlags","preciseIdentifier":"s:3GIO14ConverterFlagsV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"bytesRead"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"gsize","preciseIdentifier":"c:@T@gsize"},{"kind":"text","text":">!, "},{"kind":"externalParam","text":"bytesWritten"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"gsize","preciseIdentifier":"c:@T@gsize"},{"kind":"text","text":">!) "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"GConverterResult","preciseIdentifier":"c:@EA@GConverterResult"}],"abstract":[{"type":"text","text":"This is the main operation used when converting data. It is to be called"},{"type":"text","text":" "},{"type":"text","text":"multiple times in a loop, and each time it will do some work, i.e."},{"type":"text","text":" "},{"type":"text","text":"producing some output (in "},{"type":"codeVoice","code":"outbuf"},{"type":"text","text":") or consuming some input (from "},{"type":"codeVoice","code":"inbuf"},{"type":"text","text":") or"},{"type":"text","text":" "},{"type":"text","text":"both. If its not possible to do any work an error is returned."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/ZlibDecompressor\/convert(inbuf:inbufSize:outbuf:outbufSize:flags:bytesRead:bytesWritten:)","kind":"symbol","type":"topic","url":"\/documentation\/gio\/zlibdecompressor\/convert(inbuf:inbufsize:outbuf:outbufsize:flags:bytesread:byteswritten:)"},"doc://GIO/documentation/GIO":{"role":"collection","title":"GIO","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO","kind":"symbol","type":"topic","url":"\/documentation\/gio"},"doc://GIO/documentation/GIO/Converter":{"role":"symbol","title":"Converter","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Converter"}],"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/GIO\/documentation\/GIO\/Converter"},{"type":"text","text":" is implemented by objects that convert"},{"type":"text","text":" "},{"type":"text","text":"binary data in various ways. The conversion can be"},{"type":"text","text":" "},{"type":"text","text":"stateful and may fail at any place."}],"identifier":"doc:\/\/GIO\/documentation\/GIO\/Converter","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Converter"}],"url":"\/documentation\/gio\/converter"},"doc://GIO/documentation/GIO/ZlibDecompressor/ConverterProtocol-Implementations":{"role":"collectionGroup","title":"ConverterProtocol Implementations","abstract":[],"identifier":"doc:\/\/GIO\/documentation\/GIO\/ZlibDecompressor\/ConverterProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gio\/zlibdecompressor\/converterprotocol-implementations"}}}