{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CellAreaRef"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" is an abstract class for [iface"},{"type":"codeVoice","code":"Gtk.CellLayout"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"widgets (also referred to as “layouting widgets”) to interface with"},{"type":"text","text":" "},{"type":"text","text":"an arbitrary number of [class"},{"type":"codeVoice","code":"Gtk.CellRenderer"},{"type":"text","text":"]s and interact with the user"},{"type":"text","text":" "},{"type":"text","text":"for a given [iface"},{"type":"codeVoice","code":"Gtk.TreeModel"},{"type":"text","text":"] row."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The cell area handles events, focus navigation, drawing and"},{"type":"text","text":" "},{"type":"text","text":"size requests and allocations for a given row of data."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Usually users dont have to interact with the "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" directly"},{"type":"text","text":" "},{"type":"text","text":"unless they are implementing a cell-layouting widget themselves."}]},{"anchor":"Requesting-area-sizes","level":2,"type":"heading","text":"Requesting area sizes"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As outlined in"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"class.Widget.html`height-for-width-geometry-management`"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"GTK uses a height-for-width"},{"type":"text","text":" "},{"type":"text","text":"geometry management system to compute the sizes of widgets and user"},{"type":"text","text":" "},{"type":"text","text":"interfaces. "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" uses the same semantics to calculate the"},{"type":"text","text":" "},{"type":"text","text":"size of an area for an arbitrary number of "},{"type":"codeVoice","code":"GtkTreeModel"},{"type":"text","text":" rows."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When requesting the size of a cell area one needs to calculate"},{"type":"text","text":" "},{"type":"text","text":"the size for a handful of rows, and this will be done differently by"},{"type":"text","text":" "},{"type":"text","text":"different layouting widgets. For instance a [class"},{"type":"codeVoice","code":"Gtk.TreeViewColumn"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"always lines up the areas from top to bottom while a [class"},{"type":"codeVoice","code":"Gtk.IconView"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"on the other hand might enforce that all areas received the same"},{"type":"text","text":" "},{"type":"text","text":"width and wrap the areas around, requesting height for more cell"},{"type":"text","text":" "},{"type":"text","text":"areas when allocated less width."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s also important for areas to maintain some cell"},{"type":"text","text":" "},{"type":"text","text":"alignments with areas rendered for adjacent rows (cells can"},{"type":"text","text":" "},{"type":"text","text":"appear “columnized” inside an area even when the size of"},{"type":"text","text":" "},{"type":"text","text":"cells are different in each row). For this reason the "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" "},{"type":"text","text":"uses a [class"},{"type":"codeVoice","code":"Gtk.CellAreaContext"},{"type":"text","text":"] object to store the alignments"},{"type":"text","text":" "},{"type":"text","text":"and sizes along the way (as well as the overall largest minimum"},{"type":"text","text":" "},{"type":"text","text":"and natural size for all the rows which have been calculated"},{"type":"text","text":" "},{"type":"text","text":"with the said context)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The [class"},{"type":"codeVoice","code":"Gtk.CellAreaContext"},{"type":"text","text":"] is an opaque object specific to the"},{"type":"text","text":" "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" which created it (see [method"},{"type":"codeVoice","code":"Gtk.CellArea.create_context"},{"type":"text","text":"])."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The owning cell-layouting widget can create as many contexts as"},{"type":"text","text":" "},{"type":"text","text":"it wishes to calculate sizes of rows which should receive the"},{"type":"text","text":" "},{"type":"text","text":"same size in at least one orientation (horizontally or vertically),"},{"type":"text","text":" "},{"type":"text","text":"However, it’s important that the same [class"},{"type":"codeVoice","code":"Gtk.CellAreaContext"},{"type":"text","text":"] which"},{"type":"text","text":" "},{"type":"text","text":"was used to request the sizes for a given "},{"type":"codeVoice","code":"GtkTreeModel"},{"type":"text","text":" row be"},{"type":"text","text":" "},{"type":"text","text":"used when rendering or processing events for that row."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to request the width of all the rows at the root level"},{"type":"text","text":" "},{"type":"text","text":"of a "},{"type":"codeVoice","code":"GtkTreeModel"},{"type":"text","text":" one would do the following:"}]},{"type":"codeListing","syntax":"c","code":["GtkTreeIter iter;","int minimum_width;","int natural_width;","","valid = gtk_tree_model_get_iter_first (model, &iter);","while (valid)","  {","    gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);","    gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);","","    valid = gtk_tree_model_iter_next (model, &iter);","  }","","gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that in this example it’s not important to observe the"},{"type":"text","text":" "},{"type":"text","text":"returned minimum and natural width of the area for each row"},{"type":"text","text":" "},{"type":"text","text":"unless the cell-layouting object is actually interested in the"},{"type":"text","text":" "},{"type":"text","text":"widths of individual rows. The overall width is however stored"},{"type":"text","text":" "},{"type":"text","text":"in the accompanying "},{"type":"codeVoice","code":"GtkCellAreaContext"},{"type":"text","text":" object and can be consulted"},{"type":"text","text":" "},{"type":"text","text":"at any time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This can be useful since "},{"type":"codeVoice","code":"GtkCellLayout"},{"type":"text","text":" widgets usually have to"},{"type":"text","text":" "},{"type":"text","text":"support requesting and rendering rows in treemodels with an"},{"type":"text","text":" "},{"type":"text","text":"exceedingly large amount of rows. The "},{"type":"codeVoice","code":"GtkCellLayout"},{"type":"text","text":" widget in"},{"type":"text","text":" "},{"type":"text","text":"that case would calculate the required width of the rows in an"},{"type":"text","text":" "},{"type":"text","text":"idle or timeout source (see [func"},{"type":"codeVoice","code":"GLib.timeout_add"},{"type":"text","text":"]) and when the widget"},{"type":"text","text":" "},{"type":"text","text":"is requested its actual width in [vfunc"},{"type":"codeVoice","code":"Gtk.Widget.measure"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"it can simply consult the width accumulated so far in the"},{"type":"text","text":" "},{"type":"codeVoice","code":"GtkCellAreaContext"},{"type":"text","text":" object."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A simple example where rows are rendered from top to bottom and"},{"type":"text","text":" "},{"type":"text","text":"take up the full width of the layouting widget would look like:"}]},{"type":"codeListing","syntax":"c","code":["static void","foo_get_preferred_width (GtkWidget *widget,","                         int       *minimum_size,","                         int       *natural_size)","{","  Foo *self = FOO (widget);","  FooPrivate *priv = foo_get_instance_private (self);","","  foo_ensure_at_least_one_handfull_of_rows_have_been_requested (self);","","  gtk_cell_area_context_get_preferred_width (priv-&gt;context, minimum_size, natural_size);","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the above example the "},{"type":"codeVoice","code":"Foo"},{"type":"text","text":" widget has to make sure that some"},{"type":"text","text":" "},{"type":"text","text":"row sizes have been calculated (the amount of rows that "},{"type":"codeVoice","code":"Foo"},{"type":"text","text":" judged"},{"type":"text","text":" "},{"type":"text","text":"was appropriate to request space for in a single timeout iteration)"},{"type":"text","text":" "},{"type":"text","text":"before simply returning the amount of space required by the area via"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"GtkCellAreaContext"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Requesting the height for width (or width for height) of an area is"},{"type":"text","text":" "},{"type":"text","text":"a similar task except in this case the "},{"type":"codeVoice","code":"GtkCellAreaContext"},{"type":"text","text":" does not"},{"type":"text","text":" "},{"type":"text","text":"store the data (actually, it does not know how much space the layouting"},{"type":"text","text":" "},{"type":"text","text":"widget plans to allocate it for every row. It’s up to the layouting"},{"type":"text","text":" "},{"type":"text","text":"widget to render each row of data with the appropriate height and"},{"type":"text","text":" "},{"type":"text","text":"width which was requested by the "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to request the height for width of all the rows at the"},{"type":"text","text":" "},{"type":"text","text":"root level of a "},{"type":"codeVoice","code":"GtkTreeModel"},{"type":"text","text":" one would do the following:"}]},{"type":"codeListing","syntax":"c","code":["GtkTreeIter iter;","int minimum_height;","int natural_height;","int full_minimum_height = 0;","int full_natural_height = 0;","","valid = gtk_tree_model_get_iter_first (model, &iter);","while (valid)","  {","    gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);","    gtk_cell_area_get_preferred_height_for_width (area, context, widget,","                                                  width, &minimum_height, &natural_height);","","    if (width_is_for_allocation)","       cache_row_height (&iter, minimum_height, natural_height);","","    full_minimum_height += minimum_height;","    full_natural_height += natural_height;","","    valid = gtk_tree_model_iter_next (model, &iter);","  }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that in the above example we would need to cache the heights"},{"type":"text","text":" "},{"type":"text","text":"returned for each row so that we would know what sizes to render the"},{"type":"text","text":" "},{"type":"text","text":"areas for each row. However we would only want to really cache the"},{"type":"text","text":" "},{"type":"text","text":"heights if the request is intended for the layouting widgets real"},{"type":"text","text":" "},{"type":"text","text":"allocation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In some cases the layouting widget is requested the height for an"},{"type":"text","text":" "},{"type":"text","text":"arbitrary for_width, this is a special case for layouting widgets"},{"type":"text","text":" "},{"type":"text","text":"who need to request size for tens of thousands  of rows. For this"},{"type":"text","text":" "},{"type":"text","text":"case it’s only important that the layouting widget calculate"},{"type":"text","text":" "},{"type":"text","text":"one reasonably sized chunk of rows and return that height"},{"type":"text","text":" "},{"type":"text","text":"synchronously. The reasoning here is that any layouting widget is"},{"type":"text","text":" "},{"type":"text","text":"at least capable of synchronously calculating enough height to fill"},{"type":"text","text":" "},{"type":"text","text":"the screen height (or scrolled window height) in response to a single"},{"type":"text","text":" "},{"type":"text","text":"call to [vfunc"},{"type":"codeVoice","code":"Gtk.Widget.measure"},{"type":"text","text":"]. Returning"},{"type":"text","text":" "},{"type":"text","text":"a perfect height for width that is larger than the screen area is"},{"type":"text","text":" "},{"type":"text","text":"inconsequential since after the layouting receives an allocation"},{"type":"text","text":" "},{"type":"text","text":"from a scrolled window it simply continues to drive the scrollbar"},{"type":"text","text":" "},{"type":"text","text":"values while more and more height is required for the row heights"},{"type":"text","text":" "},{"type":"text","text":"that are calculated in the background."}]},{"anchor":"Rendering-Areas","level":2,"type":"heading","text":"Rendering Areas"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once area sizes have been acquired at least for the rows in the"},{"type":"text","text":" "},{"type":"text","text":"visible area of the layouting widget they can be rendered at"},{"type":"text","text":" "},{"type":"text","text":"[vfunc"},{"type":"codeVoice","code":"Gtk.Widget.snapshot"},{"type":"text","text":"] time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A crude example of how to render all the rows at the root level"},{"type":"text","text":" "},{"type":"text","text":"runs as follows:"}]},{"type":"codeListing","syntax":"c","code":["GtkAllocation allocation;","GdkRectangle cell_area = { 0, };","GtkTreeIter iter;","int minimum_width;","int natural_width;","","gtk_widget_get_allocation (widget, &allocation);","cell_area.width = allocation.width;","","valid = gtk_tree_model_get_iter_first (model, &iter);","while (valid)","  {","    cell_area.height = get_cached_height_for_row (&iter);","","    gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);","    gtk_cell_area_render (area, context, widget, cr,","                          &cell_area, &cell_area, state_flags, FALSE);","","    cell_area.y += cell_area.height;","","    valid = gtk_tree_model_iter_next (model, &iter);","  }"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the cached height in this example really depends on how"},{"type":"text","text":" "},{"type":"text","text":"the layouting widget works. The layouting widget might decide to"},{"type":"text","text":" "},{"type":"text","text":"give every row its minimum or natural height or, if the model content"},{"type":"text","text":" "},{"type":"text","text":"is expected to fit inside the layouting widget without scrolling, it"},{"type":"text","text":" "},{"type":"text","text":"would make sense to calculate the allocation for each row at"},{"type":"text","text":" "},{"type":"text","text":"the time the widget is allocated using [func"},{"type":"codeVoice","code":"Gtk.distribute_natural_allocation"},{"type":"text","text":"]."}]},{"anchor":"Handling-Events-and-Driving-Keyboard-Focus","level":2,"type":"heading","text":"Handling Events and Driving Keyboard Focus"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Passing events to the area is as simple as handling events on any"},{"type":"text","text":" "},{"type":"text","text":"normal widget and then passing them to the [method"},{"type":"codeVoice","code":"Gtk.CellArea.event"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"API as they come in. Usually "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" is only interested in"},{"type":"text","text":" "},{"type":"text","text":"button events, however some customized derived areas can be implemented"},{"type":"text","text":" "},{"type":"text","text":"who are interested in handling other events. Handling an event can"},{"type":"text","text":" "},{"type":"text","text":"trigger the ["},{"type":"codeVoice","code":"signal"},{"type":"text","text":"Gtk.CellArea::focus-changed"},{"type":"codeVoice","code":"] signal to fire; as well as [`signal`Gtk.CellArea::add-editable"},{"type":"text","text":"] in the case that an editable cell"},{"type":"text","text":" "},{"type":"text","text":"was clicked and needs to start editing. You can call"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gtk.CellArea.stop_editing"},{"type":"text","text":"] at any time to cancel any cell editing"},{"type":"text","text":" "},{"type":"text","text":"that is currently in progress."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" drives keyboard focus from cell to cell in a way"},{"type":"text","text":" "},{"type":"text","text":"similar to "},{"type":"codeVoice","code":"GtkWidget"},{"type":"text","text":". For layouting widgets that support giving"},{"type":"text","text":" "},{"type":"text","text":"focus to cells it’s important to remember to pass "},{"type":"codeVoice","code":"GTK_CELL_RENDERER_FOCUSED"},{"type":"text","text":" "},{"type":"text","text":"to the area functions for the row that has focus and to tell the"},{"type":"text","text":" "},{"type":"text","text":"area to paint the focus at render time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Layouting widgets that accept focus on cells should implement the"},{"type":"text","text":" "},{"type":"text","text":"[vfunc"},{"type":"codeVoice","code":"Gtk.Widget.focus"},{"type":"text","text":"] virtual method. The layouting widget is always"},{"type":"text","text":" "},{"type":"text","text":"responsible for knowing where "},{"type":"codeVoice","code":"GtkTreeModel"},{"type":"text","text":" rows are rendered inside"},{"type":"text","text":" "},{"type":"text","text":"the widget, so at [vfunc"},{"type":"codeVoice","code":"Gtk.Widget.focus"},{"type":"text","text":"] time the layouting widget"},{"type":"text","text":" "},{"type":"text","text":"should use the "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" methods to navigate focus inside the area"},{"type":"text","text":" "},{"type":"text","text":"and then observe the [enum"},{"type":"codeVoice","code":"Gtk.DirectionType"},{"type":"text","text":"] to pass the focus to adjacent"},{"type":"text","text":" "},{"type":"text","text":"rows and areas."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A basic example of how the [vfunc"},{"type":"codeVoice","code":"Gtk.Widget.focus"},{"type":"text","text":"] virtual method"},{"type":"text","text":" "},{"type":"text","text":"should be implemented:"}]},{"type":"codeListing","syntax":null,"code":["static gboolean","foo_focus (GtkWidget       *widget,","           GtkDirectionType direction)","{","  Foo *self = FOO (widget);","  FooPrivate *priv = foo_get_instance_private (self);","  int focus_row = priv-&gt;focus_row;","  gboolean have_focus = FALSE;","","  if (!gtk_widget_has_focus (widget))","    gtk_widget_grab_focus (widget);","","  valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &iter, NULL, priv-&gt;focus_row);","  while (valid)","    {","      gtk_cell_area_apply_attributes (priv-&gt;area, priv-&gt;model, &iter, FALSE, FALSE);","","      if (gtk_cell_area_focus (priv-&gt;area, direction))","        {","           priv-&gt;focus_row = focus_row;","           have_focus = TRUE;","           break;","        }","      else","        {","          if (direction == GTK_DIR_RIGHT ||","              direction == GTK_DIR_LEFT)","            break;","          else if (direction == GTK_DIR_UP ||","                   direction == GTK_DIR_TAB_BACKWARD)","           {","              if (focus_row == 0)","                break;","              else","               {","                  focus_row--;","                  valid = gtk_tree_model_iter_nth_child (priv-&gt;model, &iter, NULL, focus_row);","               }","            }","          else","            {","              if (focus_row == last_row)","                break;","              else","                {","                  focus_row++;","                  valid = gtk_tree_model_iter_next (priv-&gt;model, &iter);","                }","            }","        }","    }","    return have_focus;","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the layouting widget is responsible for matching the"},{"type":"text","text":" "},{"type":"codeVoice","code":"GtkDirectionType"},{"type":"text","text":" values to the way it lays out its cells."}]},{"anchor":"Cell-Properties","level":2,"type":"heading","text":"Cell Properties"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" introduces cell properties for "},{"type":"codeVoice","code":"GtkCellRenderer"},{"type":"text","text":"s."},{"type":"text","text":" "},{"type":"text","text":"This provides some general interfaces for defining the relationship"},{"type":"text","text":" "},{"type":"text","text":"cell areas have with their cells. For instance in a [class"},{"type":"codeVoice","code":"Gtk.CellAreaBox"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"a cell might “expand” and receive extra space when the area is allocated"},{"type":"text","text":" "},{"type":"text","text":"more than its full natural request, or a cell might be configured to “align”"},{"type":"text","text":" "},{"type":"text","text":"with adjacent rows which were requested and rendered with the same"},{"type":"text","text":" "},{"type":"codeVoice","code":"GtkCellAreaContext"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use [method"},{"type":"codeVoice","code":"Gtk.CellAreaClass.install_cell_property"},{"type":"text","text":"] to install cell"},{"type":"text","text":" "},{"type":"text","text":"properties for a cell area class and [method"},{"type":"codeVoice","code":"Gtk.CellAreaClass.find_cell_property"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"or [method"},{"type":"codeVoice","code":"Gtk.CellAreaClass.list_cell_properties"},{"type":"text","text":"] to get information about"},{"type":"text","text":" "},{"type":"text","text":"existing cell properties."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To set the value of a cell property, use [method"},{"type":"codeVoice","code":"Gtk.CellArea.cell_set_property"},{"type":"text","text":"],"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gtk.CellArea.cell_set"},{"type":"text","text":"] or [method"},{"type":"codeVoice","code":"Gtk.CellArea.cell_set_valist"},{"type":"text","text":"]. To obtain"},{"type":"text","text":" "},{"type":"text","text":"the value of a cell property, use [method"},{"type":"codeVoice","code":"Gtk.CellArea.cell_get_property"},{"type":"text","text":"]"},{"type":"text","text":" "},{"type":"text","text":"[method"},{"type":"codeVoice","code":"Gtk.CellArea.cell_get"},{"type":"text","text":"] or [method"},{"type":"codeVoice","code":"Gtk.CellArea.cell_get_valist"},{"type":"text","text":"]."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"CellAreaRef"},{"type":"text","text":" type acts as a lightweight Swift reference to an underlying "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" instance."},{"type":"text","text":" "},{"type":"text","text":"It exposes methods that can operate on this data type through "},{"type":"codeVoice","code":"CellAreaProtocol"},{"type":"text","text":" conformance."},{"type":"text","text":" "},{"type":"text","text":"Use "},{"type":"codeVoice","code":"CellAreaRef"},{"type":"text","text":" only as an "},{"type":"codeVoice","code":"unowned"},{"type":"text","text":" reference to an existing "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" instance."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/gtk\/cellarearef"],"traits":[{"interfaceLanguage":"swift"}]}],"relationshipsSections":[{"identifiers":["doc:\/\/Gtk\/documentation\/Gtk\/BuildableProtocol","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaProtocol","doc:\/\/Gtk\/documentation\/Gtk\/CellLayoutProtocol","doc:\/\/Gtk\/4GLib14PointerWrapperP","doc:\/\/Gtk\/10GLibObject14GWeakCapturingP","doc:\/\/Gtk\/10GLibObject24InitiallyUnownedProtocolP","doc:\/\/Gtk\/10GLibObject0B8ProtocolP"],"kind":"relationships","title":"Conforms To","type":"conformsTo"}],"identifier":{"url":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"An abstract class for laying out "},{"type":"codeVoice","code":"GtkCellRenderer"},{"type":"text","text":"s"}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CellAreaRef"}],"title":"CellAreaRef","roleHeading":"Structure","role":"symbol","symbolKind":"struct","externalID":"s:3Gtk11CellAreaRefV","modules":[{"name":"Gtk"}],"navigatorTitle":[{"kind":"identifier","text":"CellAreaRef"}]},"hierarchy":{"paths":[["doc:\/\/Gtk\/documentation\/Gtk"]]},"topicSections":[{"title":"Initializers","identifiers":["doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-16xsn","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-2ikjq","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-3jzc2","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-7sk9o","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-9nzc","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(cPointer:)","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(constPointer:)","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(gconstpointer:)","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(gpointer:)","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(mutating:)","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(opaquePointer:)"]},{"title":"Instance Properties","identifiers":["doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/ptr"]},{"title":"Type Methods","identifiers":["doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/unowned(_:)"]},{"title":"Default Implementations","identifiers":["doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/BuildableProtocol-Implementations","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/CellAreaProtocol-Implementations","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/CellLayoutProtocol-Implementations","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/GWeakCapturing-Implementations","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/InitiallyUnownedProtocol-Implementations","doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/ObjectProtocol-Implementations"],"generated":true}],"references":{"doc://Gtk/documentation/Gtk/CellAreaRef/init(mutating:)":{"role":"symbol","title":"init(mutating:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"mutating"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeRawPointer","preciseIdentifier":"s:SV"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Unsafe untyped initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"codeVoice","code":"CellAreaProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(mutating:)","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(mutating:)"},"class.Widget.html`height-for-width-geometry-management`":{"title":"GtkWidget’s geometry management section","titleInlineContent":[{"type":"text","text":"GtkWidget’s geometry management section"}],"type":"link","identifier":"class.Widget.html`height-for-width-geometry-management`","url":"class.Widget.html`height-for-width-geometry-management`"},"doc://Gtk/documentation/Gtk/CellAreaRef/GWeakCapturing-Implementations":{"role":"collectionGroup","title":"GWeakCapturing Implementations","abstract":[],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/GWeakCapturing-Implementations","kind":"article","type":"topic","url":"\/documentation\/gtk\/cellarearef\/gweakcapturing-implementations"},"doc://Gtk/documentation/Gtk/CellAreaRef/ObjectProtocol-Implementations":{"role":"collectionGroup","title":"ObjectProtocol Implementations","abstract":[],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/ObjectProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gtk\/cellarearef\/objectprotocol-implementations"},"doc://Gtk/documentation/Gtk/CellAreaRef/BuildableProtocol-Implementations":{"role":"collectionGroup","title":"BuildableProtocol Implementations","abstract":[],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/BuildableProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gtk\/cellarearef\/buildableprotocol-implementations"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(cPointer:)":{"role":"symbol","title":"init(cPointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"cPointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Unsafe typed initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"codeVoice","code":"CellAreaProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(cPointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(cpointer:)"},"doc://Gtk/documentation/Gtk/CellAreaRef/CellLayoutProtocol-Implementations":{"role":"collectionGroup","title":"CellLayoutProtocol Implementations","abstract":[],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/CellLayoutProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gtk\/cellarearef\/celllayoutprotocol-implementations"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(_:)-7sk9o":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GtkCellArea"},{"kind":"text","text":">?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-7sk9o","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(_:)-7sk9o"},"doc://Gtk/documentation/Gtk":{"role":"collection","title":"Gtk","abstract":[],"identifier":"doc:\/\/Gtk\/documentation\/Gtk","kind":"symbol","type":"topic","url":"\/documentation\/gtk"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(_:)-9nzc":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"UnsafeMutablePointer","preciseIdentifier":"s:Sp"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GtkCellArea"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Designated initialiser from the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-9nzc","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(_:)-9nzc"},"doc://Gtk/documentation/Gtk/CellAreaRef/CellAreaProtocol-Implementations":{"role":"collectionGroup","title":"CellAreaProtocol Implementations","abstract":[],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/CellAreaProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gtk\/cellarearef\/cellareaprotocol-implementations"},"doc://Gtk/documentation/Gtk/CellAreaRef/unowned(_:)":{"role":"symbol","title":"unowned(_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"unowned"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"CellAreaRef","preciseIdentifier":"s:3Gtk11CellAreaRefV"}],"abstract":[{"type":"text","text":"This factory is syntactic sugar for setting weak pointers wrapped in "},{"type":"codeVoice","code":"GWeak<T>"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/unowned(_:)","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/unowned(_:)"},"doc://Gtk/10GLibObject24InitiallyUnownedProtocolP":{"type":"unresolvable","title":"GLibObject.InitiallyUnownedProtocol","identifier":"doc:\/\/Gtk\/10GLibObject24InitiallyUnownedProtocolP"},"doc://Gtk/documentation/Gtk/CellAreaRef/ptr":{"role":"symbol","title":"ptr","fragments":[{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"ptr"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafeMutableRawPointer","preciseIdentifier":"s:Sv"},{"kind":"text","text":"!"}],"abstract":[{"type":"text","text":"Untyped pointer to the underlying "},{"type":"codeVoice","code":"GtkCellArea"},{"type":"text","text":" instance."},{"type":"text","text":" "},{"type":"text","text":"For type-safe access, use the generated, typed pointer "},{"type":"codeVoice","code":"cell_area_ptr"},{"type":"text","text":" property instead."}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/ptr","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/ptr"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(gpointer:)":{"role":"symbol","title":"init(gpointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"externalParam","text":"gpointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"gpointer","preciseIdentifier":"c:gtypes.h@T@gpointer"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional "},{"type":"codeVoice","code":"gpointer"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(gpointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(gpointer:)"},"doc://Gtk/documentation/Gtk/CellLayoutProtocol":{"role":"symbol","title":"CellLayoutProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"CellLayoutProtocol"}],"abstract":[{"type":"text","text":"An interface for packing cells"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellLayoutProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CellLayoutProtocol"}],"url":"\/documentation\/gtk\/celllayoutprotocol"},"doc://Gtk/documentation/Gtk/CellAreaRef":{"role":"symbol","title":"CellAreaRef","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CellAreaRef"}],"abstract":[{"type":"text","text":"An abstract class for laying out "},{"type":"codeVoice","code":"GtkCellRenderer"},{"type":"text","text":"s"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CellAreaRef"}],"url":"\/documentation\/gtk\/cellarearef"},"doc://Gtk/10GLibObject14GWeakCapturingP":{"type":"unresolvable","title":"GLibObject.GWeakCapturing","identifier":"doc:\/\/Gtk\/10GLibObject14GWeakCapturingP"},"doc://Gtk/documentation/Gtk/CellAreaRef/InitiallyUnownedProtocol-Implementations":{"role":"collectionGroup","title":"InitiallyUnownedProtocol Implementations","abstract":[],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/InitiallyUnownedProtocol-Implementations","kind":"article","type":"topic","url":"\/documentation\/gtk\/cellarearef\/initiallyunownedprotocol-implementations"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(_:)-2ikjq":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GtkCellArea"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Designated initialiser from a constant pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-2ikjq","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(_:)-2ikjq"},"doc://Gtk/documentation/Gtk/CellAreaProtocol":{"role":"symbol","title":"CellAreaProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"CellAreaProtocol"}],"abstract":[{"type":"text","text":"An abstract class for laying out "},{"type":"codeVoice","code":"GtkCellRenderer"},{"type":"text","text":"s"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CellAreaProtocol"}],"url":"\/documentation\/gtk\/cellareaprotocol"},"doc://Gtk/10GLibObject0B8ProtocolP":{"type":"unresolvable","title":"GLibObject.ObjectProtocol","identifier":"doc:\/\/Gtk\/10GLibObject0B8ProtocolP"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(_:)-16xsn":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"GtkCellArea"},{"kind":"text","text":">?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional, non-mutable pointer to the underlying "},{"type":"codeVoice","code":"C"},{"type":"text","text":" data type"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-16xsn","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(_:)-16xsn"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(gconstpointer:)":{"role":"symbol","title":"init(gconstpointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"!("},{"kind":"externalParam","text":"gconstpointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"gconstpointer","preciseIdentifier":"c:gtypes.h@T@gconstpointer"},{"kind":"text","text":"?)"}],"abstract":[{"type":"text","text":"Conditional initialiser from an optional, non-mutable "},{"type":"codeVoice","code":"gconstpointer"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(gconstpointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(gconstpointer:)"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(constPointer:)":{"role":"symbol","title":"init(constPointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"constPointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"UnsafePointer","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":">)"}],"abstract":[{"type":"text","text":"Unsafe typed initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"codeVoice","code":"CellAreaProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(constPointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(constpointer:)"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(_:)-3jzc2":{"role":"symbol","title":"init(_:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Reference intialiser for a related type that implements "},{"type":"codeVoice","code":"CellAreaProtocol"}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(_:)-3jzc2","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(_:)-3jzc2"},"doc://Gtk/4GLib14PointerWrapperP":{"type":"unresolvable","title":"GLib.PointerWrapper","identifier":"doc:\/\/Gtk\/4GLib14PointerWrapperP"},"doc://Gtk/documentation/Gtk/CellAreaRef/init(opaquePointer:)":{"role":"symbol","title":"init(opaquePointer:)","fragments":[{"kind":"identifier","text":"init"},{"kind":"text","text":"("},{"kind":"externalParam","text":"opaquePointer"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"OpaquePointer","preciseIdentifier":"s:s13OpaquePointerV"},{"kind":"text","text":")"}],"abstract":[{"type":"text","text":"Unsafe untyped initialiser."},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"text","text":"Do not use unless you know the underlying data type the pointer points to conforms to "},{"type":"codeVoice","code":"CellAreaProtocol"},{"type":"text","text":"."}]}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/CellAreaRef\/init(opaquePointer:)","kind":"symbol","type":"topic","url":"\/documentation\/gtk\/cellarearef\/init(opaquepointer:)"},"doc://Gtk/documentation/Gtk/BuildableProtocol":{"role":"symbol","title":"BuildableProtocol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"BuildableProtocol"}],"abstract":[{"type":"codeVoice","code":"GtkBuildable"},{"type":"text","text":" allows objects to extend and customize their deserialization"},{"type":"text","text":" "},{"type":"text","text":"from ui files."}],"identifier":"doc:\/\/Gtk\/documentation\/Gtk\/BuildableProtocol","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"BuildableProtocol"}],"url":"\/documentation\/gtk\/buildableprotocol"}}}