{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"TypeValueCollectFunc"},{"kind":"text","text":" = "},{"kind":"typeIdentifier","text":"GTypeValueCollectFunc","preciseIdentifier":"c:@T@GTypeValueCollectFunc"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"discussion","level":2,"type":"heading","text":"Discussion"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This function should setup "},{"type":"codeVoice","code":"value"},{"type":"text","text":" similar to "},{"type":"codeVoice","code":"GTypeValueInitFunc"},{"type":"text","text":"; e.g."},{"type":"text","text":" "},{"type":"text","text":"for a string value that does not allow "},{"type":"codeVoice","code":"NULL"},{"type":"text","text":" pointers, it needs to either"},{"type":"text","text":" "},{"type":"text","text":"emit an error, or do an implicit conversion by storing an empty string."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"value"},{"type":"text","text":" passed in to this function has a zero-filled data array, so"},{"type":"text","text":" "},{"type":"text","text":"just like for "},{"type":"codeVoice","code":"GTypeValueInitFunc"},{"type":"text","text":" it is guaranteed to not contain any old"},{"type":"text","text":" "},{"type":"text","text":"contents that might need freeing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"n_collect_values"},{"type":"text","text":" argument is the string length of the "},{"type":"codeVoice","code":"collect_format"},{"type":"text","text":" "},{"type":"text","text":"field of "},{"type":"codeVoice","code":"GTypeValueTable"},{"type":"text","text":", and "},{"type":"codeVoice","code":"collect_values"},{"type":"text","text":" is an array of "},{"type":"codeVoice","code":"GTypeCValue"},{"type":"text","text":" "},{"type":"text","text":"with length of "},{"type":"codeVoice","code":"n_collect_values"},{"type":"text","text":", containing the collected values according"},{"type":"text","text":" "},{"type":"text","text":"to "},{"type":"codeVoice","code":"collect_format"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"collect_flags"},{"type":"text","text":" argument provided as a hint by the caller. It may"},{"type":"text","text":" "},{"type":"text","text":"contain the flag "},{"type":"codeVoice","code":"G_VALUE_NOCOPY_CONTENTS"},{"type":"text","text":" indicating that the collected"},{"type":"text","text":" "},{"type":"text","text":"value contents may be considered ‘static’ for the duration of the "},{"type":"codeVoice","code":"value"},{"type":"text","text":" "},{"type":"text","text":"lifetime. Thus an extra copy of the contents stored in "},{"type":"codeVoice","code":"collect_values"},{"type":"text","text":" is"},{"type":"text","text":" "},{"type":"text","text":"not required for assignment to "},{"type":"codeVoice","code":"value"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For our above string example, we continue with:"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"(C Language Example):"}]},{"type":"codeListing","syntax":"C","code":["if (!collect_values[0].v_pointer)","  value->data[0].v_pointer = g_strdup (\"\");","else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)","  {","    value->data[0].v_pointer = collect_values[0].v_pointer;","    \/\/ keep a flag for the value_free() implementation to not free this string","    value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;","  }","else","  value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);","return NULL;"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It should be noted, that it is generally a bad idea to follow the"},{"type":"text","text":" "},{"type":"codeVoice","code":"G_VALUE_NOCOPY_CONTENTS"},{"type":"text","text":" hint for reference counted types. Due to"},{"type":"text","text":" "},{"type":"text","text":"reentrancy requirements and reference count assertions performed"},{"type":"text","text":" "},{"type":"text","text":"by the signal emission code, reference counts should always be"},{"type":"text","text":" "},{"type":"text","text":"incremented for reference counted contents stored in the "},{"type":"codeVoice","code":"value-&gt;data"},{"type":"text","text":" "},{"type":"text","text":"array. To deviate from our string example for a moment, and taking"},{"type":"text","text":" "},{"type":"text","text":"a look at an exemplary implementation for "},{"type":"codeVoice","code":"GTypeValueTable.collect_value()"},{"type":"text","text":" "},{"type":"text","text":"of "},{"type":"codeVoice","code":"GObject"},{"type":"text","text":":"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"(C Language Example):"}]},{"type":"codeListing","syntax":"C","code":["GObject *object = G_OBJECT (collect_values[0].v_pointer);","g_return_val_if_fail (object != NULL,","   g_strdup_printf (\"Object %p passed as invalid NULL pointer\", object));","\/\/ never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types","value->data[0].v_pointer = g_object_ref (object);","return NULL;"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The reference count for valid objects is always incremented, regardless"},{"type":"text","text":" "},{"type":"text","text":"of "},{"type":"codeVoice","code":"collect_flags"},{"type":"text","text":". For invalid objects, the example returns a newly"},{"type":"text","text":" "},{"type":"text","text":"allocated string without altering "},{"type":"codeVoice","code":"value"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Upon success, "},{"type":"codeVoice","code":"collect_value()"},{"type":"text","text":" needs to return "},{"type":"codeVoice","code":"NULL"},{"type":"text","text":". If, however,"},{"type":"text","text":" "},{"type":"text","text":"an error condition occurred, "},{"type":"codeVoice","code":"collect_value()"},{"type":"text","text":" should return a newly"},{"type":"text","text":" "},{"type":"text","text":"allocated string containing an error diagnostic."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The calling code makes no assumptions about the "},{"type":"codeVoice","code":"value"},{"type":"text","text":" contents being"},{"type":"text","text":" "},{"type":"text","text":"valid upon error returns, "},{"type":"codeVoice","code":"value"},{"type":"text","text":" is simply thrown away without further"},{"type":"text","text":" "},{"type":"text","text":"freeing. As such, it is a good idea to not allocate "},{"type":"codeVoice","code":"GValue"},{"type":"text","text":" contents"},{"type":"text","text":" "},{"type":"text","text":"prior to returning an error; however, "},{"type":"codeVoice","code":"collect_values()"},{"type":"text","text":" is not obliged"},{"type":"text","text":" "},{"type":"text","text":"to return a correctly setup "},{"type":"codeVoice","code":"value"},{"type":"text","text":" for error returns, simply because"},{"type":"text","text":" "},{"type":"text","text":"any non-"},{"type":"codeVoice","code":"NULL"},{"type":"text","text":" return is considered a fatal programming error, and"},{"type":"text","text":" "},{"type":"text","text":"further program behaviour is undefined."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/glibobject\/typevaluecollectfunc"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/GLibObject\/documentation\/GLibObject\/TypeValueCollectFunc","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"This function is responsible for converting the values collected from"},{"type":"text","text":" "},{"type":"text","text":"a variadic argument list into contents suitable for storage in a "},{"type":"codeVoice","code":"GValue"},{"type":"text","text":"."}],"kind":"symbol","metadata":{"fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"TypeValueCollectFunc"}],"title":"TypeValueCollectFunc","roleHeading":"Type Alias","role":"symbol","symbolKind":"typealias","externalID":"s:10GLibObject20TypeValueCollectFunca","modules":[{"name":"GLibObject"}],"navigatorTitle":[{"kind":"identifier","text":"TypeValueCollectFunc"}]},"hierarchy":{"paths":[["doc:\/\/GLibObject\/documentation\/GLibObject"]]},"references":{"doc://GLibObject/documentation/GLibObject/TypeValueCollectFunc":{"role":"symbol","title":"TypeValueCollectFunc","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"TypeValueCollectFunc"}],"abstract":[{"type":"text","text":"This function is responsible for converting the values collected from"},{"type":"text","text":" "},{"type":"text","text":"a variadic argument list into contents suitable for storage in a "},{"type":"codeVoice","code":"GValue"},{"type":"text","text":"."}],"identifier":"doc:\/\/GLibObject\/documentation\/GLibObject\/TypeValueCollectFunc","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TypeValueCollectFunc"}],"url":"\/documentation\/glibobject\/typevaluecollectfunc"},"doc://GLibObject/documentation/GLibObject":{"role":"collection","title":"GLibObject","abstract":[],"identifier":"doc:\/\/GLibObject\/documentation\/GLibObject","kind":"symbol","type":"topic","url":"\/documentation\/glibobject"}}}